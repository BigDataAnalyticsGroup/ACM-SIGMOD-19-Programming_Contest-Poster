\documentclass[a1paper,portrait,american,fontscale=.4]{baposter}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{todo}
\usepackage{hyperref}
\usepackage{qrcode}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{setspace}
\usepackage{bm}
\usepackage{tikz}
\usetikzlibrary{
    arrows,
    arrows.meta,
    backgrounds,
    calc,
    chains,
    decorations,
    decorations.pathreplacing,
    matrix,
    positioning,
    scopes,
    shadows,
    shapes,
    shapes.multipart,
    shapes.arrows,
}

\makeatletter
\def\parsecomma#1,#2\endparsecomma{\def\page@x{#1}\def\page@y{#2}}
\tikzdeclarecoordinatesystem{page}{
    \parsecomma#1\endparsecomma
    \pgfpointanchor{current page}{north east}
    % Save the upper right corner
    \pgf@xc=\pgf@x%
    \pgf@yc=\pgf@y%
    % save the lower left corner
    \pgfpointanchor{current page}{south west}
    \pgf@xb=\pgf@x%
    \pgf@yb=\pgf@y%
    % Transform to the correct placement
    \pgfmathparse{(\pgf@xc-\pgf@xb)/2.*\page@x+(\pgf@xc+\pgf@xb)/2.}
    \expandafter\pgf@x\expandafter=\pgfmathresult pt
    \pgfmathparse{(\pgf@yc-\pgf@yb)/2.*\page@y+(\pgf@yc+\pgf@yb)/2.}
    \expandafter\pgf@y\expandafter=\pgfmathresult pt
}
\makeatother

\definecolor{MyColorOne}{HTML}{637462}
\definecolor{MyColorTwo}{HTML}{b7af8a}
\definecolor{MyColorThree}{HTML}{ccb15a}
\colorlet{MyBoxBG}{white!96!black}

\tikzstyle{rect}=[draw,rectangle,thick,on chain,font=\tiny,inner sep=.5mm,minimum height=1.2em]
\tikzstyle{ssd}=[draw,rectangle,rounded corners,very thick,minimum width=3cm,minimum height=4cm]
\tikzstyle{ssd_screw}=[circle,fill=black!50!white,inner sep=0mm,minimum width=2mm]
\tikzstyle{memory}=[draw,rectangle,very thick,minimum width=18mm,minimum height=40mm]
\tikzstyle{file}=[draw,rectangle,minimum width=15mm,text width=15mm,minimum height=20mm,align=center]
\tikzstyle{fat_arrow}=[->,>={Triangle[length=7mm,width=10mm]},line width=6mm]

\newcommand{\SSD}[3][]{%
    \node[ssd,#1] (#2) {#3};
    \node[below=1mm] at (#2.north) {\textbf{#2}};
    \node[ssd_screw,xshift=2mm,yshift=-2mm] at (#2.north west) {};
    \node[ssd_screw,xshift=-2mm,yshift=-2mm] at (#2.north east) {};
    \node[ssd_screw,xshift=2mm,yshift=2mm] at (#2.south west) {};
    \node[ssd_screw,xshift=-2mm,yshift=2mm] at (#2.south east) {};
}

\newcommand{\Memory}[3][]{%
    \node[memory,#1] (#2) {#3};
    \node[below=1mm,text width=15mm,align=center] at (#2.north) {\textbf{#2}};
}

\newcommand{\File}[2][]{%
    \node[file,#1] (#2)
        {%
            \ttfamily\tiny
            01000001010000\\
            11010011010010\\
            00000101001101\\
            00100101000111\\
            01001101010011\\
            11010001000010\\
            00000011001000\\
            11000000110001\\
            00111001\phantom{000000}\\

        };
    \node[above] at (#2.north) {\textbf{\footnotesize #2}};
}

\newcommand{\CPU}[3][]{%
    \node[draw,rectangle,very thick,minimum width=22mm,minimum height=22mm,#1] (#2) {};
    \node[draw,rectangle,very thick,rounded corners, minimum width=19mm,minimum height=19mm] at (#2) {#3};
    \node[below=3mm] at (#2.north) {\textbf{#2}};
}

\begin{document}
\begin{poster}{
        %----- Poster Settings -----------------------------------------------------------------------------------------
        background=none,
        columns=6,
        %----- Box Settings --------------------------------------------------------------------------------------------
        boxColorOne=MyBoxBG,
        boxshade=plain,
        headershade=shadeLR,
        headerColorOne=MyColorOne,
        headerColorTwo=MyColorTwo,
        textborder=roundedleft,
        borderColor=black,
        headerborder=open,
        headershape=roundedright,
        headerfont=\large\bfseries,
        headerFontColor=white!90!MyColorTwo,
        linewidth=0pt,
    }
    {}
    {
        \LARGE ACM~SIGMOD'19~Programming~Contest
    }
    {
        \vspace*{.5em}
        \emph{teamsic:}~Immanuel~L.~Haffner
        \qquad
        Advisor:~Jens~Dittrich
        \\[.5em]
        \small
        Big~Data~Analytics~Group, Saarland~Informatics~Campus
        \\[.5em]
        \url{bigdata.uni-saarland.de}
    }
    {
    }

    \headerbox{Task Description}{name=task,column=0,span=3}{
        \begin{center}
            \scalebox{.8}{\input{fig/overview.tex}}
        \end{center}
    }

    \headerbox{In-Memory Sorting}{name=inmemory,column=3,span=3}{
        \textbf{Algorithm:}
        \vspace{-.5em}
        \begin{enumerate}
            \footnotesize
            \setlength{\itemsep}{0em}
            \item predict record type (ASCII [32-126] or binary [0-255])
            \item predict bucket sizes
            \item partition into 256 buckets
            \item sort each bucket
        \end{enumerate}

        \textbf{Tricks:}
        \vspace{-.5em}
        \begin{itemize}
            \setlength{\itemsep}{0em}
            \item avoid write to disk with \texttt{mmap()} \emph{\small\#thankskernel}
            \item keys are uniformly distributed
            \item partition into \texttt{mmap}'d output file while reading from disk:

            \begin{minipage}{.85\linewidth}
                \begin{algorithmic}\footnotesize
                    \State buckets $\gets$ \texttt{mmap(...)} \Comment{consecutive memory}
                    \For {%
                    \tikz[remember picture]{\coordinate (algo_start);}%
                    record $r$ \textbf{in} input file} \Comment{read from disk}
                        \State bucket $b \gets$ buckets[$r.k_0$] \Comment{initial partitioning}
                        \If {$b$ \textbf{is full}} \Comment{underestimated bucket size}
                            \State append $r$ to overflow bucket $i$
                        \Else
                            \State append $r$ to $b$
                        \EndIf
                    \EndFor
                    \State \emph{patch\_overflow()}
                \end{algorithmic}
            \end{minipage}
        \end{itemize}
    }


    \headerbox{Sorting Algorithm}{name=algo,column=3,span=3,below=inmemory}{
        \begin{itemize}
            \item in-place radix sort with \emph{American Flag Sort}
            \item parallelize on first recursion: use one thread per call (work list) or all threads per call
            \item custom concurrent American Flag Sort partitioning
            \item fall back to \texttt{std::sort()} below certain threshold (i.e.\ \emph{introsort} with fall back to
                \emph{insertion sort})
        \end{itemize}

        \begin{center}
            \includegraphics[scale=.05]{fig/parallel_AFS.jpg}
        \end{center}
    }

    \headerbox{External Memory Sorting}{name=external,column=0,span=3,below=task}{
        \begin{itemize}
            \item read as much data as fits into main memory
            \item sort that data with parallel American Flag Sort on NUMA region~0
            \item in parallel, partition remaining data into 256 buckets on SSD1 on NUMA region~1
            \item starting with the smallest bucket, load a bucket, sort it, then merge the bucket with the sorted in
                memory data and write it to the output file on disk
        \end{itemize}

        \begin{center}
            \includegraphics[scale=.2]{fig/external_sort_1.jpg}
            \includegraphics[scale=.2]{fig/external_sort_2.jpg}
        \end{center}

        \begin{minipage}[t][66mm][c]{.53\textwidth}
            \includegraphics[scale=.18]{fig/timeline.png}
        \end{minipage}%
        \begin{minipage}[t][66mm][c]{.47\textwidth}
            \begin{enumerate}
                \item Read the first $M - \epsilon$ records into main memory.
                \item Start to sort the $M - \epsilon$ records.
                \item[2'.] Concurrently read the remaining $N - (M - \epsilon)$ records and partition them into $256$ buckets
                    on SSD1.

                \item Load the next smallest partition into main memory.
                \item Sort the records in the partition.
                \item Merge the sorted partition with the sorted in-memory data and write to output file on SSD1.
            \end{enumerate}
        \end{minipage}
    }

    \headerbox{Third-Party Libraries}{name=libs,column=3,span=2,below=algo}{
        \begin{itemize}
            \item Agner Fog's \texttt{asmlib} {\footnotesize (for \texttt{memcmp()})}
            \item CTPL: Modern and Efficient C\texttt{++} Thread Pool Library {\footnotesize (not in final submission)}
            \item Intel Processor Counter Monitor (PCM) {\footnotesize (not in final submission)}
        \end{itemize}
    }

    \headerbox{Source Code}{name=code,column=3,span=2,below=libs}{
        \begin{minipage}[b]{.65\linewidth}
            The source code is available on Github and licensed under Apache~v2.
        \end{minipage}%
        \begin{minipage}[t]{.35\linewidth}
            \begin{flushright}
                \qrcode[height=22mm]{https://git.io/fjazH}
                \\[.5em]
                \mbox{\url{git.io/fjazH}}
            \end{flushright}
        \end{minipage}
    }
\end{poster}

\begin{tikzpicture}[overlay,remember picture]
    \coordinate (arr_task_to_inmemory) at (page cs:0,.32);
    \coordinate (arr_task_to_external) at (page cs:-.20,.26);

    \draw[fat_arrow,draw=MyColorOne] ([xshift=-8mm]arr_task_to_inmemory) to
        node[white,font=\ttfamily\footnotesize] {<\,30\,GiB}
        ([xshift=8mm]arr_task_to_inmemory);
    \draw[fat_arrow,draw=MyColorOne] ([yshift=8mm]arr_task_to_external) to
        node[white,font=\ttfamily\footnotesize,rotate=90] {$\bm\geqslant$\,30\,GiB}
        ([yshift=-8mm]arr_task_to_external);
\end{tikzpicture}

\vspace*{-6em}
\begin{flushright}
    \footnotesize
    Big~Data~Analytics~Group \\[.5em]
    \url{bigdata.uni-saarland.de} \\[.5em]
    Saarland~Informatics~Campus \\[.5em]
\end{flushright}
\clearpage
\todos

\begin{algorithm}
    \caption{In-Memory Sorting}
    \begin{algorithmic}
        \State predict record type (ASCII [32-126] or binary [0-255])
        \State estimate bucket sizes
        \For {record $r$ \textbf{in} input file} \Comment{read from disk}
            \State bucket\_id $i \gets r.k_0$
            \State bucket $b \gets$ buckets[$i$] \Comment{initial partitioning}
            \If {$b$ \textbf{is full}} \Comment{underestimated bucket size}
                \State append $r$ to overflow bucket $i$
            \Else
                \State append $r$ to $b$
            \EndIf
        \EndFor
        \State patch overflow
        \For {every bucket $b$} \Comment{in parallel}
            \State \emph{american\_flag\_sort}$(b)$
        \EndFor
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{External Sorting}
    \begin{algorithmic}
        \State $n \gets$ number of records that fit into main memory $- \epsilon$
        \State read first $n$ records into main memory
        \State sort first $n$ records \Comment{in separate thread}
        \State partition remaining records into 256~files
        \For {every partition file $p$, sorted in ascending file size}
            \State merge $p$ with sorted, in-memory records to output file on disk
        \EndFor
    \end{algorithmic}
\end{algorithm}

\end{document}
